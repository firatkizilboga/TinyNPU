#!/usr/bin/env python3
"""
Generate hex data files for systolic array matrix multiplication tests.

Usage:
    python gen_test_data.py --m 4 --k 12 --n 4 --output buffer_init_k12.hex
    
This generates:
    - A (M×K) input matrix stored column-major
    - B (K×N) weight matrix stored column-major
    - Expected C = A × B result
"""

import argparse
import numpy as np


def pack_column(col, width=16):
    """Pack a column of N values into a 64-bit hex string.
    
    Packing order: [elem3][elem2][elem1][elem0] = col[3], col[2], col[1], col[0]
    """
    assert len(col) == 4, f"Column must have 4 elements, got {len(col)}"
    packed = 0
    for i, val in enumerate(col):
        val = int(val) & ((1 << width) - 1)  # Mask to width bits
        packed |= val << (i * width)
    return f"{packed:016X}"


def generate_matrix(rows, cols, pattern='increment', base=1):
    """Generate a matrix with various patterns.
    
    Patterns:
        'increment': A[i][k] = base + i*cols + k
        'identity': A[i][k] = 1 if i == k else 0
        'ones': A[i][k] = 1
        'random': Random integers 1-10
    """
    if pattern == 'increment':
        return np.array([[base + i*cols + k for k in range(cols)] for i in range(rows)], dtype=np.int32)
    elif pattern == 'identity':
        return np.eye(rows, cols, dtype=np.int32)
    elif pattern == 'ones':
        return np.ones((rows, cols), dtype=np.int32)
    elif pattern == 'random':
        return np.random.randint(1, 11, size=(rows, cols), dtype=np.int32)
    else:
        raise ValueError(f"Unknown pattern: {pattern}")


def matrix_to_hex_columns(mat):
    """Convert matrix to list of hex strings (column-major order).
    
    Returns list of hex strings, one per column.
    """
    rows, cols = mat.shape
    assert rows == 4, f"Matrix must have 4 rows (systolic array size), got {rows}"
    
    hex_lines = []
    for k in range(cols):
        col = [mat[i, k] for i in range(4)]
        hex_lines.append(pack_column(col))
    return hex_lines


def generate_hex_file(m, k, n, output_path, a_pattern='increment', b_pattern='ones'):
    """Generate hex file for M×K × K×N matrix multiplication."""
    
    # Generate matrices
    A = generate_matrix(m, k, pattern=a_pattern, base=1)
    B = generate_matrix(k, n, pattern=b_pattern, base=1)
    C = A @ B  # Expected result
    
    print(f"Matrix A ({m}×{k}):")
    print(A)
    print(f"\nMatrix B ({k}×{n}):")
    print(B)
    print(f"\nExpected C = A × B ({m}×{n}):")
    print(C)
    
    # Build hex file content
    lines = []
    lines.append("// Auto-generated by gen_test_data.py")
    lines.append(f"// Matrix multiplication: A({m}x{k}) x B({k}x{n}) = C({m}x{n})")
    lines.append("")
    
    # Row 0: Sentinel
    lines.append("// Row 0: Sentinel (DEAD pattern)")
    lines.append("DEADDEADDEADDEAD")
    lines.append("")
    
    # Rows 1 to K: Matrix A columns
    a_start = 1
    lines.append(f"// Rows {a_start}-{a_start+k-1}: Matrix A columns (column-major)")
    a_hex = matrix_to_hex_columns(A)
    for i, h in enumerate(a_hex):
        lines.append(f"{h}  // A col {i}")
    lines.append("")
    
    # Padding to align B at row 16 (or next power of 2)
    b_start = ((a_start + k + 7) // 8) * 8  # Align to 8-row boundary
    padding_count = b_start - (a_start + k)
    if padding_count > 0:
        lines.append(f"// Rows {a_start+k}-{b_start-1}: Padding")
        for _ in range(padding_count):
            lines.append("0000000000000000")
        lines.append("")
    
    # Rows b_start to b_start+K-1: Matrix B columns
    lines.append(f"// Rows {b_start}-{b_start+k-1}: Matrix B columns (column-major)")
    b_hex = matrix_to_hex_columns(B.T)  # Need to transpose for proper column-major
    # Actually B is K×N, we need to feed columns of B, but B needs special handling
    # For systolic: we feed B column by column where each "column" of B corresponds to
    # the weights for one output column. So B[:, j] feeds to systolic column j.
    # But our packing expects 4 elements. B is K×N, K can be > 4.
    # Wait - the skewer handles ROWS of the UB entry, not matrix rows.
    # Each UB word has 4 elements. So for B (K×N where N=4):
    # We store B transposed so that we can read column j of B as one sequence.
    # Hmm, this is getting confusing. Let me reconsider.
    
    # Actually: The skewer takes a UB word (4 elements) and delays each element differently.
    # For the weight skewer, we feed one "row" of B per cycle.
    # But B is K×N (e.g., 12×4). We have 12 rows of 4 elements each.
    # So we store B row-major: Row 0 of B, Row 1 of B, ..., Row K-1 of B.
    # Wait that's what I should do for B!
    
    # Let me reconsider the data flow:
    # - A (M×K): We feed columns of A. Each column has M=4 elements. K columns total.
    # - B (K×N): We feed rows of B. Each row has N=4 elements. K rows total.
    # Actually no - let me check the existing test:
    # The existing 4×4 test stores A columns and B columns (identity matrix columns).
    # For identity matrix (4×4), column j has 1 in position j.
    # When fed to weight skewer, this produces the right timing.
    
    # For B (K×N), we need to think about what arrives at PE[i][j].
    # PE[i][j] computes C[i][j] = sum_k A[i][k] * B[k][j]
    # Weight for PE[:][j] comes from column j of B: [B[0][j], B[1][j], ..., B[K-1][j]]
    # The weight skewer feeds to columns 0-3 of the systolic array.
    # So we feed B column-major: B[:, 0], B[:, 1], B[:, 2], B[:, 3]
    # Each B[:, j] is K elements, but we can only pack 4 per word!
    
    # Ah! For K>4, we need multiple UB words per column of B.
    # This requires rethinking the memory layout.
    
    # Actually, the skewer ALWAYS outputs 4 elements per cycle.
    # For K=12, we need 12 cycles of feeding.
    # Each cycle, we feed 4 elements from A (one column of A) and 4 elements from B.
    # But wait - A column has 4 elements (M=4), that's fine.
    # B column has K=12 elements. We can't feed that in one word!
    
    # I think the solution is: B must be laid out so that we feed K words for weights.
    # Each word has 4 elements: [B[k][0], B[k][1], B[k][2], B[k][3]] for k=0..11
    # This is row-major storage of B.
    # At cycle k, we feed:
    #   A input: column k of A = [A[0][k], A[1][k], A[2][k], A[3][k]]
    #   B weight: row k of B = [B[k][0], B[k][1], B[k][2], B[k][3]]
    # This makes sense! The skewer delays each element:
    #   A[i][k] is delayed by i+1 cycles before entering systolic row i
    #   B[k][j] is delayed by j+1 cycles before entering systolic column j
    # Then at PE[i][j], A[i][k] and B[k][j] meet at the right time.
    
    lines_b = []
    lines_b.append(f"// Rows {b_start}-{b_start+k-1}: Matrix B rows (row-major)")
    for kk in range(k):
        row = [B[kk, j] for j in range(n)]
        # Pad to 4 if needed
        while len(row) < 4:
            row.append(0)
        lines_b.append(f"{pack_column(row)}  // B row {kk}")
    
    lines.extend(lines_b)
    lines.append("")
    
    # Padding to fill out the file
    total_rows = b_start + k
    final_size = ((total_rows + 7) // 8) * 8
    if final_size > total_rows:
        lines.append(f"// Rows {total_rows}-{final_size-1}: Padding")
        for _ in range(final_size - total_rows):
            lines.append("0000000000000000")
    
    # Write file
    with open(output_path, 'w') as f:
        for line in lines:
            f.write(line + '\n')
    
    print(f"\nWrote hex file to: {output_path}")
    print(f"  A address range: {a_start} to {a_start+k-1}")
    print(f"  B address range: {b_start} to {b_start+k-1}")
    
    return A, B, C, a_start, b_start


def main():
    parser = argparse.ArgumentParser(description='Generate test data for systolic array')
    parser.add_argument('-m', '--m', type=int, default=4, help='M dimension (rows of A, must be 4)')
    parser.add_argument('-k', '--k', type=int, default=4, help='K dimension (cols of A, rows of B)')
    parser.add_argument('-n', '--n', type=int, default=4, help='N dimension (cols of B, must be 4)')
    parser.add_argument('-o', '--output', type=str, default='buffer_init_test.hex', help='Output hex file')
    parser.add_argument('--a-pattern', type=str, default='increment', 
                        choices=['increment', 'identity', 'ones', 'random'],
                        help='Pattern for matrix A')
    parser.add_argument('--b-pattern', type=str, default='ones',
                        choices=['increment', 'identity', 'ones', 'random'],
                        help='Pattern for matrix B')
    
    args = parser.parse_args()
    
    if args.m != 4:
        print("Warning: M must be 4 for 4x4 systolic array. Forcing M=4.")
        args.m = 4
    if args.n != 4:
        print("Warning: N must be 4 for 4x4 systolic array. Forcing N=4.")
        args.n = 4
    
    generate_hex_file(args.m, args.k, args.n, args.output, args.a_pattern, args.b_pattern)


if __name__ == '__main__':
    main()
